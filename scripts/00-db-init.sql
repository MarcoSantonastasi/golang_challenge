DROP TABLE IF EXISTS accounts CASCADE;
DROP TYPE IF EXISTS type_account_type;
CREATE TYPE type_account_type AS ENUM ('INVESTOR', 'ISSUER', 'ESCROW', 'CASH');
CREATE TABLE accounts
(
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    created_at timestamp with time zone DEFAULT now(),
    name character varying COLLATE pg_catalog."default",
    type type_account_type NOT NULL,
    balance bigint NOT NULL DEFAULT 0::bigint,
    CONSTRAINT accounts_pkey PRIMARY KEY (id)
);
COMMENT ON TABLE accounts
	IS 'Accounts are an accounting object necessary to keep the ledger';


DROP TABLE IF EXISTS invoices CASCADE;
CREATE TABLE invoices
(
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    created_at timestamp with time zone DEFAULT now(),
    issuer uuid NOT NULL,
    denom character varying(3) NOT NULL DEFAULT 'EUR',
    amount bigint,
    asking bigint NOT NULL,
    is_biddable boolean NOT NULL DEFAULT true,
    CONSTRAINT invoices_pkey PRIMARY KEY (id),
    CONSTRAINT invoices_issuer_fkey FOREIGN KEY (issuer)
      REFERENCES accounts(id) MATCH SIMPLE
      ON UPDATE NO ACTION
      ON DELETE NO ACTION
);
COMMENT ON TABLE invoices
    IS 'Invoices are the document that is traded. Numeric fields representing currency are always in cents of the denomination (i.e. a value of 100 = 1 currency unit)';


DROP TABLE IF EXISTS transactions CASCADE;
CREATE TABLE transactions
(
    id bigint GENERATED BY DEFAULT AS IDENTITY,
    created_at timestamp with time zone DEFAULT now(),
    is_active boolean NOT NULL DEFAULT true,
    invoice uuid,
    CONSTRAINT transactions_pkey PRIMARY KEY (id),
    CONSTRAINT transactions_invoice_fkey FOREIGN KEY (invoice)
      REFERENCES invoices(id) MATCH SIMPLE
      ON UPDATE NO ACTION
      ON DELETE NO ACTION
);
CREATE UNIQUE INDEX
  ON transactions (invoice, is_active)
  WHERE is_active = true;
COMMENT ON TABLE transactions
    IS 'Transactions are an accounting object needed to reconcile ledger entries';


DROP TABLE IF EXISTS ledger CASCADE;
CREATE TABLE ledger
(
    id bigint GENERATED BY DEFAULT AS IDENTITY,
    created_at timestamp with time zone DEFAULT now(),
    transaction bigint NOT NULL,
    credit uuid NOT NULL,
    debit uuid NOT NULL,
    amount int NOT NULL,
    CONSTRAINT ledger_pkey PRIMARY KEY (id),
    CONSTRAINT ledger_transaction_fkey FOREIGN KEY (transaction)
      REFERENCES transactions(id) MATCH SIMPLE
      ON UPDATE NO ACTION
      ON DELETE NO ACTION,
    CONSTRAINT ledger_credit_fkey FOREIGN KEY (credit)
      REFERENCES accounts(id) MATCH SIMPLE
      ON UPDATE NO ACTION
      ON DELETE NO ACTION,
    CONSTRAINT ledger_debit_fkey FOREIGN KEY (debit)
      REFERENCES accounts(id) MATCH SIMPLE
      ON UPDATE NO ACTION
      ON DELETE NO ACTION
);
COMMENT ON TABLE ledger
    IS 'Ledger records all tranfers of money,a nd matches it with a transaction for reconciliation';


CREATE OR REPLACE FUNCTION update_account_balance_on_ledger_insert() 
RETURNS TRIGGER AS $$
BEGIN
  UPDATE accounts
  SET balance = balance + new.amount
  WHERE id = new.credit;
  UPDATE accounts
  SET balance = balance - new.amount
  WHERE id = new.debit;
RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER update_account_balance_on_ledger_insert
AFTER INSERT ON ledger
    FOR EACH ROW EXECUTE FUNCTION update_account_balance_on_ledger_insert();


CREATE OR REPLACE FUNCTION check_sufficient_balance_on_ledger_insert()
RETURNS TRIGGER AS $$
DECLARE
  _balance bigint;
BEGIN
  SELECT balance FROM accounts
  WHERE id = new.debit
  INTO _balance;
  
  IF new.amount > _balance THEN
    RAISE EXCEPTION 'insufficient funds';
   END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER check_sufficient_balance_on_ledger_insert
BEFORE INSERT ON ledger
    FOR EACH ROW EXECUTE FUNCTION check_sufficient_balance_on_ledger_insert();


CREATE OR REPLACE FUNCTION bid (
  INOUT _bidder_account uuid,
  INOUT _invoice uuid,
  INOUT _offer bigint
) 
AS $$
DECLARE
  _esc uuid;
  _tx bigint;

BEGIN
-- SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

SELECT id FROM accounts
WHERE
  type='ESCROW'::type_account_type
FETCH FIRST ROW ONLY
INTO _esc;

INSERT INTO transactions (invoice)
VALUES (_invoice)
RETURNING id INTO _tx;

EXCEPTION WHEN unique_violation THEN
SELECT id FROM transactions
WHERE
  invoice = _invoice AND
  is_active = true
INTO _tx;

INSERT INTO ledger( transaction, credit, debit, amount)
VALUES (_tx, _esc, _bidder_account, _offer);

RETURN;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION revert_outstanding_bids (
  INOUT _invoice uuid,
  OUT _offer bigint
)
AS $$
DECLARE
  _tx bigint;
  _esc uuid;
  _account RECORD;
  _credit bigint;
  _debit bigint;

BEGIN

-- SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

SELECT id FROM transactions
WHERE
  invoice = _invoice AND
  is_active = true
INTO _tx;

SELECT id FROM accounts
WHERE
  type='ESCROW'::type_account_type
INTO _esc;

FOR _account IN (
  SELECT debit AS _id FROM ledger
    WHERE transaction = _tx
  UNION
  SELECT credit AS _id FROM ledger
    WHERE transaction = _tx
)
LOOP

  SELECT SUM(amount) FROM ledger
  WHERE
    transaction=_transaction AND
    credit= _esc AND
    debit= _account
  INTO _credit;

  SELECT SUM(amount) FROM ledger
  WHERE
    transaction=_transaction AND
    credit= _account AND
    debit=  _esc
  INTO _debit;

  INSERT INTO ledger( transaction, credit, debit, amount)
    VALUES (_tx, _esc, _account, (coalesce(_credit,0::int) - coalesce(_debit,0::int)));
  
END LOOP;

UPDATE transactions SET is_active = false
  WHERE invoice = _invoice;

RETURN;
END; 
$$ LANGUAGE plpgsql;
