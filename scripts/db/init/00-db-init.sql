DROP TABLE IF EXISTS accounts CASCADE;
DROP TYPE IF EXISTS type_account_type;
CREATE TYPE type_account_type AS ENUM ('INVESTOR', 'ISSUER', 'ESCROW', 'CASH');
CREATE TABLE accounts
(
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    created_at timestamp with time zone DEFAULT now(),
    name character varying COLLATE pg_catalog."default",
    type type_account_type NOT NULL,
    balance bigint NOT NULL DEFAULT 0::bigint,
    CONSTRAINT accounts_pkey PRIMARY KEY (id)
);
COMMENT ON TABLE accounts
	IS 'Accounts are an accounting object necessary to keep the ledger';


DROP TABLE IF EXISTS invoices CASCADE;
CREATE TABLE invoices
(
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    created_at timestamp with time zone DEFAULT now(),
    issuer uuid NOT NULL,
    denom character varying(3) NOT NULL DEFAULT 'EUR',
    amount bigint,
    asking bigint NOT NULL,
    is_biddable boolean NOT NULL DEFAULT true,
    CONSTRAINT invoices_pkey PRIMARY KEY (id),
    CONSTRAINT invoices_issuer_fkey FOREIGN KEY (issuer)
      REFERENCES accounts(id) MATCH SIMPLE
      ON UPDATE NO ACTION
      ON DELETE NO ACTION
);
COMMENT ON TABLE invoices
    IS 'Invoices are the document that is traded. Numeric fields representing currency are always in cents of the denomination (i.e. a value of 100 = 1 currency unit)';


DROP TABLE IF EXISTS transactions CASCADE;
CREATE TABLE transactions
(
    id bigint GENERATED BY DEFAULT AS IDENTITY,
    created_at timestamp with time zone DEFAULT now(),
    is_active boolean NOT NULL DEFAULT true,
    invoice uuid,
    CONSTRAINT transactions_pkey PRIMARY KEY (id),
    CONSTRAINT transactions_invoice_fkey FOREIGN KEY (invoice)
      REFERENCES invoices(id) MATCH SIMPLE
      ON UPDATE NO ACTION
      ON DELETE NO ACTION
);
CREATE UNIQUE INDEX
  ON transactions (invoice, is_active)
  WHERE is_active = true;
COMMENT ON TABLE transactions
    IS 'Transactions are an accounting object needed to reconcile ledger entries';


DROP TABLE IF EXISTS ledger CASCADE;
CREATE TABLE ledger
(
    id bigint GENERATED BY DEFAULT AS IDENTITY,
    created_at timestamp with time zone DEFAULT now(),
    transaction bigint NOT NULL,
    credit uuid NOT NULL,
    debit uuid NOT NULL,
    amount int NOT NULL,
    CONSTRAINT ledger_pkey PRIMARY KEY (id),
    CONSTRAINT ledger_transaction_fkey FOREIGN KEY (transaction)
      REFERENCES transactions(id) MATCH SIMPLE
      ON UPDATE NO ACTION
      ON DELETE NO ACTION,
    CONSTRAINT ledger_credit_fkey FOREIGN KEY (credit)
      REFERENCES accounts(id) MATCH SIMPLE
      ON UPDATE NO ACTION
      ON DELETE NO ACTION,
    CONSTRAINT ledger_debit_fkey FOREIGN KEY (debit)
      REFERENCES accounts(id) MATCH SIMPLE
      ON UPDATE NO ACTION
      ON DELETE NO ACTION
);
COMMENT ON TABLE ledger
    IS 'Ledger records all tranfers of money,a nd matches it with a transaction for reconciliation';


CREATE OR REPLACE VIEW bids (
  transaction,
  invoice,
  issuer,
  bidder_account,
  amount
)
AS (
  SELECT
    tx.id as transaction,
    tx.invoice as invoice,
    inv.issuer as issuer,
    bid_up.debit as bidder_account,
    coalesce(bid_up.amount, 0::bigint) - coalesce(bid_down.amount, 0::bigint) as amount
  FROM transactions as tx
  JOIN invoices as inv ON tx.invoice = inv.id
  JOIN (SELECT id FROM accounts WHERE type = 'ESCROW'::type_account_type FETCH FIRST ROW ONLY) as escrow ON true
  LEFT JOIN LATERAL (
    SELECT
      transaction,
      debit,
      sum(amount) as amount
    FROM ledger l
    WHERE l.credit = escrow.id
    GROUP BY transaction, debit
    ) AS bid_up ON bid_up.transaction = tx.id
  LEFT JOIN LATERAL (
    SELECT
      transaction,
      credit,
      sum(amount)as amount
    FROM ledger l
    WHERE l.debit = escrow.id
    GROUP BY transaction, credit
    ) AS bid_down ON bid_down.transaction = tx.id
  WHERE tx.is_active = true
);


CREATE OR REPLACE FUNCTION update_account_balance_on_ledger_insert() 
RETURNS TRIGGER AS $$
BEGIN
  UPDATE accounts
  SET balance = balance + new.amount
  WHERE id = new.credit;
  UPDATE accounts
  SET balance = balance - new.amount
  WHERE id = new.debit;
RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER update_account_balance_on_ledger_insert
AFTER INSERT ON ledger
    FOR EACH ROW EXECUTE FUNCTION update_account_balance_on_ledger_insert();


CREATE OR REPLACE FUNCTION check_sufficient_balance_on_ledger_insert()
RETURNS TRIGGER AS $$
DECLARE
  _balance bigint;
BEGIN
  SELECT balance FROM accounts
  WHERE id = new.debit
  INTO _balance;
  
  IF new.amount > _balance THEN
    RAISE EXCEPTION 'insufficient funds';
   END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER check_sufficient_balance_on_ledger_insert
BEFORE INSERT ON ledger
    FOR EACH ROW EXECUTE FUNCTION check_sufficient_balance_on_ledger_insert();


CREATE OR REPLACE FUNCTION bid (
  INOUT _bidder_account uuid,
  INOUT _invoice uuid,
  INOUT _offer bigint
) 
AS $$
DECLARE
  _esc uuid;
  _tx bigint;

BEGIN

SELECT id FROM accounts
WHERE
  type='ESCROW'::type_account_type
FETCH FIRST ROW ONLY
INTO _esc;

LOOP
  SELECT id FROM transactions
  WHERE
    invoice = _invoice AND
    is_active = true
  INTO _tx;

  EXIT WHEN FOUND;

  INSERT INTO transactions (invoice)
  VALUES (_invoice)
  RETURNING id INTO _tx;

  EXIT WHEN FOUND;
END LOOP;

INSERT INTO ledger( transaction, credit, debit, amount)
VALUES (_tx, _esc, _bidder_account, _offer);

RETURN;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION revert_outstanding_bids (
  INOUT _invoice uuid,
  OUT _offer bigint
)
AS $$
DECLARE
  _tx bigint;
  _esc uuid;
  _account RECORD;
  _credit bigint;
  _debit bigint;

BEGIN

SELECT id FROM transactions
WHERE
  invoice = _invoice AND
  is_active = true
INTO _tx;

SELECT id FROM accounts
WHERE
  type='ESCROW'::type_account_type
INTO _esc;

FOR _account IN (
  SELECT debit AS _id FROM ledger
    WHERE transaction = _tx
  UNION
  SELECT credit AS _id FROM ledger
    WHERE transaction = _tx
)
LOOP

  SELECT SUM(amount) FROM ledger
  WHERE
    transaction = _tx AND
    credit= _esc AND
    debit= _account._id
  INTO _credit;

  SELECT SUM(amount) FROM ledger
  WHERE
    transaction = _tx AND
    credit= _account._id AND
    debit=  _esc
  INTO _debit;

  INSERT INTO ledger( transaction, credit, debit, amount)
    VALUES (_tx, _account._id, _esc, (coalesce(_credit,0::bigint) - coalesce(_debit,0::bigint)));
  
END LOOP;

UPDATE transactions
SET is_active = false
WHERE invoice = _invoice;

RETURN;
END; 
$$ LANGUAGE plpgsql;
