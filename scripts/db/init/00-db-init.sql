DROP TABLE IF EXISTS accounts CASCADE;
DROP TYPE IF EXISTS type_account_type;
CREATE TYPE type_account_type AS ENUM ('INVESTOR', 'ISSUER', 'ESCROW', 'CASH');
CREATE TABLE accounts
(
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    created_at timestamp with time zone DEFAULT now(),
    name character varying COLLATE pg_catalog."default",
    type type_account_type NOT NULL,
    balance bigint NOT NULL DEFAULT 0::bigint,
    CONSTRAINT accounts_pkey PRIMARY KEY (id)
);
COMMENT ON TABLE accounts IS
  'Accounts are abstract identifiers of parties in a monetary transaction. They are of four types: INVESTOR, ISSUER, ESCROW, CASH';


DROP TABLE IF EXISTS invoices CASCADE;
DROP TYPE IF EXISTS type_invoice_state;
CREATE TYPE type_invoice_state AS ENUM ('OPEN', 'ADJUDICATED', 'FINANCED');
CREATE TABLE invoices
(
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    created_at timestamp with time zone DEFAULT now(),
    issuer_id uuid NOT NULL,
    reference varchar NOT NULL,
    denom character varying(3) NOT NULL DEFAULT 'EUR',
    amount bigint,
    asking bigint NOT NULL,
    state type_invoice_state NOT NULL DEFAULT 'OPEN',
    CONSTRAINT invoices_pkey PRIMARY KEY (id),
    CONSTRAINT invoices_issuer_id_fkey FOREIGN KEY (issuer_id)
      REFERENCES accounts(id) MATCH SIMPLE
      ON UPDATE NO ACTION
      ON DELETE NO ACTION,
    CONSTRAINT invoices_issuer_id_reference_unique UNIQUE (issuer_id, reference)
);
COMMENT ON TABLE invoices IS
  'Invoices are the documents that are auctioned, the asking field representing the minimum value the issuer is willing to acept. Numeric fields representing currency are always in cents of the denomination (i.e. a value of 100 = 1 currency unit)';


DROP TABLE IF EXISTS bids CASCADE;
DROP TYPE IF EXISTS type_bid_state;
CREATE TYPE type_bid_state AS ENUM ('ACTIVE', 'LOST', 'WON');
CREATE TABLE bids
(
    id bigint GENERATED BY DEFAULT AS IDENTITY,
    created_at timestamp with time zone DEFAULT now(),
    invoice_id uuid NOT NULL,
    bidder_account_id uuid NOT NULL,
    offer bigint NOT NULL,
    state type_bid_state NOT NULL DEFAULT 'ACTIVE'::type_bid_state,
    CONSTRAINT bids_pkey PRIMARY KEY (id),
    CONSTRAINT bids_invoice_id_fkey FOREIGN KEY (invoice_id)
      REFERENCES invoices(id) MATCH SIMPLE
      ON UPDATE NO ACTION
      ON DELETE NO ACTION,
    CONSTRAINT bids_bidder_account_id_fkey FOREIGN KEY (bidder_account_id)
      REFERENCES accounts(id) MATCH SIMPLE
      ON UPDATE NO ACTION
      ON DELETE NO ACTION,
    CONSTRAINT bids_invoice_id_bidder_account_id_state_unique UNIQUE(invoice_id, bidder_account_id, state)
);
COMMENT ON TABLE ledger IS
  'Bids represent Investor offers on invoices. They are the grouping abstraction for reconciling money transactions related to auctioning activity';


DROP TABLE IF EXISTS transactions CASCADE;
CREATE TABLE transactions
(
    id bigint GENERATED BY DEFAULT AS IDENTITY,
    created_at timestamp with time zone DEFAULT now(),
    bid_id bigint,
    credit_account_id uuid NOT NULL,
    debit_account_id uuid NOT NULL,
    amount bigint NOT NULL,
    CONSTRAINT transactions_pkey PRIMARY KEY (id),
    CONSTRAINT transactions_bid_id_fkey FOREIGN KEY (bid_id)
      REFERENCES bids(id) MATCH SIMPLE
      ON UPDATE NO ACTION
      ON DELETE NO ACTION,
    CONSTRAINT transactions_credit_account_id_fkey FOREIGN KEY (credit_account_id)
      REFERENCES accounts(id) MATCH SIMPLE
      ON UPDATE NO ACTION
      ON DELETE NO ACTION,
    CONSTRAINT transactions_debit_account_id_fkey FOREIGN KEY (debit_account_id)
      REFERENCES accounts(id) MATCH SIMPLE
      ON UPDATE NO ACTION
      ON DELETE NO ACTION
);

COMMENT ON TABLE transactions IS
  'Transactions record all tranfers of money. Only if the bid_id field is populated it means that the transaction is relative to a bid and reconciliation can be done within a bididng round.';


CREATE OR REPLACE FUNCTION check_sufficient_balance_on_transactions_insert()
RETURNS TRIGGER AS $$
DECLARE
  _debit_balance bigint;
BEGIN
  SELECT balance FROM accounts
  WHERE id = new.debit_account_id
  INTO _debit_balance;
  IF new.amount > _debit_balance THEN
    RAISE EXCEPTION 'insufficient funds';
  END IF;
  RETURN new;
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE TRIGGER check_sufficient_balance_on_transactions_insert
BEFORE INSERT ON transactions
  FOR EACH ROW EXECUTE FUNCTION check_sufficient_balance_on_transactions_insert();


CREATE OR REPLACE FUNCTION update_account_balance_on_transactions_insert() 
RETURNS TRIGGER AS $$
BEGIN
  UPDATE accounts
  SET balance = balance + new.amount
  WHERE id = new.credit_account_id;
  UPDATE accounts
  SET balance = balance - new.amount
  WHERE id = new.debit_account_id;
RETURN new;
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE TRIGGER update_account_balance_on_transactions_insert
AFTER INSERT ON transactions
  FOR EACH ROW EXECUTE FUNCTION update_account_balance_on_transactions_insert();


CREATE OR REPLACE FUNCTION bid (
  INOUT _invoice_id uuid,
  INOUT _bidder_account_id uuid,
  INOUT _offer bigint
) 
AS $$
DECLARE
  _esc_account_id uuid;
  _bid_id bigint;

BEGIN

SELECT id FROM accounts
WHERE
  type='ESCROW'::type_account_type
FETCH FIRST ROW ONLY
INTO _esc_account_id;

LOOP
  SELECT id FROM bids
  WHERE
    invoice_id = _invoice_id AND
    state = 'ACTIVE'::type_bid_state
  INTO _bid_id;

  EXIT WHEN FOUND;

  INSERT INTO bids (
    invoice_id,
    bidder_account_id,
    offer
  )
  VALUES (
    _invoice_id,
    _bidder_account_id,
    _offer
  )
  ON CONFLICT DO NOTHING
  RETURNING id INTO _bid_id;
  
  EXIT WHEN FOUND;
END LOOP;

INSERT INTO transactions( bid_id, credit_account_id, debit_account_id, amount)
VALUES (_bid_id, _esc_account_id, _bidder_account_id, _offer);

RETURN;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE VIEW investors AS SELECT * FROM accounts WHERE type = 'INVESTOR'::type_account_type;


CREATE OR REPLACE VIEW issuers AS SELECT * FROM accounts WHERE type = 'ISSUER'::type_account_type;
